# 日志系统

使用**单例模式**创建日志系统，对服务器的运行状态、错误信息和访问数据进行记录，该系统实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步两种方式写入。

其中，**同步方式**写入，是让工作线程和日志写入函数用串行执行，但是由于涉及到了I/O操作，当单条日志较大时，
同步模式会阻塞整个工作线程，导致服务器的并发能力下降。

**异步方式**写入，是将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push
进队列，写线程从队列中pop出内容，写入日志文件。

日志存储在一个文本文件中，需要记录的内容包括时间、级别、文件、行号、内容，日志级别为 `dubug < info 
< warn < error < fatal`。

整个日志系统包括两部分：1. 单例模式与阻塞队列的定义；2. 日志类的定义与使用

## 需求
1. 日志存储：文本文件
2. 日志内容：时间、级别、文件、行号、内容
3. 日志级别：debug < info < warn < error < fatal
4. 日志翻滚功能：当单个日志文件大小>1M，则创建一个新的文本文件存储，防止单个日志文件过大，打开满。

## 概念解析
- **生产者-消费者模型**：并发编程中的经典模型，以多线程为例，为了实现线程间的数据同步，生产者和消费者
共享一个缓冲区，其中生产者线程往缓冲区push消息，消费者线程从缓冲区pop消息。
- **阻塞队列**：就是将生产者-消费者模型进行了封装，使用循环数组实现队列，作为生产者和消费者的缓冲区。
- **单例模式**：保证类只有一个实例，构造函数设置为私有的，同时提供公有的访问实例的方法，分为懒汉式和饿汉式
    - **懒汉式**：是在第一次使用该类时再初始化对象，在多线程编程中，需要注意线程安全问题，如果同时有多个
    线程通过了`p == NULL` 判断条件，则可能创造出多个实例来，因此一般需要加锁，通过**双检测锁**
    实现线程安全的懒汉式单例模式。（在C++11标准之后，要求编译器对静态变量的构造和访问实现线程安全，
    因此不需要额外加锁）
    - **饿汉式**：是在加载类时就初始化实例，相当于用空间换时间，优点在于实现简单，但缺点是如果该
    单例程序中一次都没有使用，就造成了资源浪费。


## 阻塞队列（`block_queue.h`）

阻塞队列是指在多线程编程时，当多个线程访问一个队列时，如果队列为空，则获取队列中元素的方法就会阻塞，直到队列中有元素可以获取。需要解决队列的线程安全问题。

c++标准库提供的队列不是线程安全的，因此在多线程编程时遇到生产者消费者模型时，每次访问队列时需要手动加锁，如果队列不是阻塞式的，每次从队列中获取元素的时候都需要对队列进行判断，如果队列为空，就continue，这种做法

> 参考：
> https://mp.weixin.qq.com/s/IWAlPzVDkR2ZRI5iirEfCg
> https://blog.csdn.net/len_yue_mo_fu/article/details/89919433